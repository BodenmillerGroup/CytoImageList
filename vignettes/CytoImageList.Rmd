---
title: "An S4 class for handling multi-channel images"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('cytomapper')`"
author:
- name: Nils Eling
  affiliation: 
  - Department for Quantitative Biomedicine, University of Zurich
  - Institute for Molecular Health Sciences, ETH Zurich
  email: nils.eling@dqbm.uzh.ch
output:
    BiocStyle::html_document:
        toc_float: yes
bibliography: library.bib
abstract: |
    Highly multiplexed imaging measures the abundance of biomolecules in tissues
    and generates multi-channel (>4) images encoding abundance levels as pixel
    intensities. Most commonly, color images are stored as 3-channel RGB or
    4-channel RGBA images. In contrast, the `CytoImageList` S4 class stores 
    multi-channel images in the format xyc where x and y are the physical 
    dimensions of the images and c the number of channels. Each channel is 
    stored as grayscale array. The package further provides getter and setter 
    functions for assessing images and channels and functionality for
    merging channels.
vignette: |
    %\VignetteIndexEntry{"Handling multi-channel images in R"}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE)
library(BiocStyle)
```

```{r library, echo=FALSE}
library(CytoImageList)
```

# Introduction

This vignette gives an introduction to handling single- and multi-channel images
in R. Multi-channel images are most commonly generated by multiplexed imaging
technologies such as multiplexed ion beam imaging (MIBI) [@angelo2014mibi],
imaging mass cytometry (IMC) [@giesen2014imc], tissue-based cyclic
immunofluorescence (t-CyCIF) [@lin2018cycif] and iterative indirect
immunofluorescence imaging (4i) [@gut20184i], among others. These technologies
acquire the spatial distribution of biomolecules (also refered to as "markers")
in tissue sections and encode this information in form of an array of the shape
`xyc`. Here, `x` and `y` indicate the physical location of the pixel in the
tissue and `c` stores pixel intensities per channel/marker.

A common task during image processing includes image segmentation. This process
generates single-channel segmentation masks which are single-channel images that
match the input images in size, with non-zero grayscale values indicating the
IDs of segmented objects.

The `CytoImageList` S4 class builds upon the `S4Vectors::SimpleList` class
and stores one single- or multi-channel image per list entry in form
of an `EBImage::Image`, `DelayedArray::DelayedArray` or `HDF5Array::HDF5Array`
object. Image handling is faciliated by providing getter and setter function to
access and replace individual images and channels and to merge channels.

The `CytoImageList` class is part of the Bioconductor project to extend the 
functionality for the `EBImage::Image` class by providing infrastructure
for on-disk handling of images and facilitating the generation of mutli-channel
composite images by using, for example, the `r BiocStyle::Biocpkg("cytomapper")`
package..

## The toy dataset {#ToyData}

For simplicity and as an example, we use toy data provided by the `r
BiocStyle::Biocpkg("cytomapper")` package  to highlight the use of the
`CytoImageList` S4 class.. The toy dataset contains 3 images of $100\mu{m}$ x
$100\mu{m}$ dimensions (100 x 100 pixels). The dataset contains 362 segmented
cells and the expression values for 5 proteins: H3, CD99, PIN, CD8a, and CDH It
represents a small subset of the data presented in [A Map of Human Type 1
Diabetes Progression by Imaging Mass
Cytometry](https://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1550413118306910%3Fshowall%3Dtrue).

This dataset was generated using imaging mass cytometry [@giesen2014imc]. Raw
output files (in .mcd format) were processed using the [IMC segmentation
pipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline), which
produces tiff-stacks containing the pixel-level information of all measured
markers, segmentation masks that contain the cells' object ids as well as cell-
and image-specific measurements. 

Pixel-level intensities for all 5 markers (5 channels) are stored in the
`pancreasImages` object. Entries to the `CytoImageList` object and the rownames
of `elementMetadata` match: E34_imc, G01_imc, and J02_imc. The `elementMetadata` slot
(accessible via the `mcols()` function) contains the image identifiers.

```{r}
library(cytomapper)
data(pancreasImages)
data(pancreasMasks)
```

```{r pancreasImages}
mcols(pancreasImages)
channelNames(pancreasImages)
imageData(pancreasImages[[1]])[1:15,1:5,1]
```

The corresponding segmentation masks are stored in the `pancreasMasks` object
and can be read in from tiff images containing the segmentation masks (see next
section).
Segmentation masks are defined as one-channel images containing integer values,
which represent the cells' ids or 0 (background).

```{r pancreasMasks}
pancreasMasks
mcols(pancreasMasks)
imageData(pancreasMasks[[1]])[1:15,1:5]
```

# The CytoImageList object {#CytoImageList}

The `CytoImageList` S4 class, which inherits from the [`SimpleList`
class](https://rdrr.io/bioc/S4Vectors/man/SimpleList-class.html). Each entry to
the `CytoImageList` object is an `Image` class object defined in the `r
BiocStyle::Biocpkg("EBImage")` package, a `DelayedArray` class object of the `r
BiocStyle::Biocpkg("DelayedArray")` package or a `HDF5Array` class object of the
`r BiocStyle::Biocpkg("HDF5Array")` package. A `CytoImageList` object is
restricted to the following entries:

* all images need to have the same number of channels
* the order/naming of channels need to be the same across all images
* entries to the `CytoImageList` object need to be uniquely named
* names of `CytoImageList` object can either be `NULL` or should not contain
`NA` or empty entries
* only grayscale images are supported (see `?Image` for more information)
* channels names do not support duplicated entries

The following paragraphs will explain further details on manipulating
`CytoImageList` objects.

## Creating a CytoImageList object

In the simplest case, the `CytoImageList` object is created via its constructor 
function:

```{r CIL-creation-1}
u <- array(rbinom(500, 10, 0.5), dim = c(10, 10, 5))
v <- array(rbinom(500, 10, 0.5), dim = c(10, 10, 5))
CIL <- CytoImageList::CytoImageList(image1 = Image(u), image2 = Image(v))
CIL
CIL$image1
```

The `Image` objects can also be created via the `EBImage` package:

```{r CIL-creation-2}
library(EBImage)

u <- readImage(system.file("extdata/E34_imc.tiff", package = "CytoImageList"))
v <- readImage(system.file("extdata/G01_imc.tiff", package = "CytoImageList"))

CIL <- CytoImageList::CytoImageList(image1 = u, image2 = v)
CIL
CIL$image1
```

## Accessors {#accessors}

All accessor functions defined for `SimpleList` also work on `CytoImageList`
class objects. Element-wise metadata --- in the case of the `CytoImageList`
object these are image-specific metadata --- are saved in the `elementMetadata`
slot. This slot can be accessed via the `mcols()` function:

```{r mcols}
mcols(pancreasImages)
mcols(pancreasImages)$PatientID <- c("Patient1", "Patient2", "Patient3")
mcols(pancreasImages)
```

Subsetting a `CytoImageList` object works similar to a `SimpleList` object:

```{r subsetting-SimpleList}
pancreasImages[1]
pancreasImages[[1]]
```

However, to facilitate subsetting and making sure that entry names are
transferred between objects, the `cytomapper` package provides a number of getter
and setter functions:

### Getting and setting images

Individual or multiple entries in a `CytoImageList` object can be obtained or
replaced using the `getImages` and `setImages` functions, respectively.

```{r get-set-images}
cur_image <- getImages(pancreasImages, "E34_imc")
cur_image
setImages(pancreasImages, "New_image") <- cur_image
pancreasImages
mcols(pancreasImages)
```

The `setImages` function ensures that names are transferred from one to the other
object along the assignment operator:

```{r set-images}
names(cur_image) <- "Replacement"
setImages(pancreasImages, 2) <- cur_image
pancreasImages
mcols(pancreasImages)
```

However, if the image to replace is called by name, only the image and
associated metadata is replaced:

```{r set-images-2}
setImages(pancreasImages, "J02_imc") <- cur_image
pancreasImages
mcols(pancreasImages)
```

Images can be deleted by setting the entry to `NULL`:

```{r deleting-images}
setImages(pancreasImages, c("Replacement", "New_image")) <- NULL
pancreasImages
```

### Getting and setting channels

The `cytomapper` package also provides functions to obtain and replace channels.
This functionality is provided via the `getChannels` and `setChannels`
functions:

```{r get-set-channels}
cur_channel <- getChannels(pancreasImages, "H3")
cur_channel
channelNames(cur_channel) <- "New_H3"
setChannels(pancreasImages, 1) <- cur_channel
pancreasImages
```

The `setChannels` function does not allow combining and adding new channels. For
this task, the `cytomapper` package provides the `mergeChannels` section in the
next paragraph.

### Naming and merging channels

Channel names can be obtained and replaced using the `channelNames` getter and
setter function:

```{r channelnames}
channelNames(pancreasImages)
channelNames(pancreasImages) <- c("ch1", "ch2", "ch3", "ch4", "ch5")
pancreasImages
```

Furthermore, channels can be merged using the `mergeChannels` function:

```{r mergechannels}
cur_channels <- getChannels(pancreasImages, 1:2)
channelNames(cur_channels) <- c("new_ch1", "new_ch2")
pancreasImages <- mergeChannels(pancreasImages, cur_channels)
pancreasImages
```

## Looping

To perform custom operations on each individual entry to a `CytoImageList`
object, the `r Biocpkg("S4Vectors")` package provides the `endoapply` function.
While the `lapply` function returns a `list` object, the `endoapply` function
provides an object of the same class of the input object.

This allows the user to apply all functions provided by the 
`r Biocpkg("EBImage")` package to individual entries within 
the `CytoImageList` object:

```{r endoapply-example}
data("pancreasImages")

# Performing a gaussian blur
pancreasImages <- endoapply(pancreasImages, gblur, sigma = 1)
```

## Storing images on disk

Images can also be stored on disk. For this the constructor function
can be used:

```{r}
CLI <- CytoImageList(image1 = u, image2 = v,
                      on_disk = TRUE, 
                      h5FilesPath = HDF5Array::getHDF5DumpDir())
CLI
CLI$image1
```

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
